<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Celeste-like JS Platformer (Keyboard + Pro Controller)</title>
<style>
  html,body,canvas {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    display: block;
    background: #0f1220;
    color: #e8ecff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto;
  }
  #wrap {
    display: flex;
    gap: 16px;
    align-items: flex-start;
    justify-content: center;
    padding: 0;
    margin: 0;
    width: 100vw;
    height: 100vh;
  }
  canvas {
    image-rendering: pixelated;
    background: #1a1e33;
    width: 100vw;
    height: 100vh;
    border: none;
    border-radius: 0;
    box-shadow: none;
    display: block;
  }
  .ui {
    max-width: 420px;
    transition: opacity 0.2s;
  }
  .btn {
    appearance: none;
    border: 0;
    padding: 10px 14px;
    border-radius: 10px;
    background: #4a67ff;
    color: #fff;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 4px 14px rgba(74,103,255,.35);
  }
  .btn:active {
    transform: translateY(1px);
  }
  .kbd {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 6px;
    background: #222744;
    border: 1px solid #39407a;
  }
  ul {
    margin: 6px 0 0 1.2em;
  }
  .pill {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 999px;
    background: #23284a;
    border: 1px solid #38417f;
    font-size: 12px;
  }
  #startScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(15, 18, 32, 0.98);
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  #startScreenInner {
    background: rgba(34, 39, 68, 0.92);
    padding: 40px 32px 32px 32px;
    border-radius: 18px;
    box-shadow: 0 8px 40px rgba(0,0,0,0.35);
    text-align: center;
    color: #fff;
    min-width: 240px;
  }
  #startScreen h1 {
    font-size: 2.2em;
    margin-bottom: 0.5em;
    margin-top: 0;
    font-weight: 700;
    letter-spacing: 2px;
  }
  #startScreen .btn {
    margin: 1em 0.5em 0 0.5em;
    min-width: 120px;
    font-size: 1.1em;
  }
  #startScreen p {
    margin-top: 1.2em;
    color: #cbd8ff;
    font-size: 1em;
    opacity: 0.85;
  }
</style>
</head>
<body>
<div id="startScreen">
  <div id="startScreenInner">
    <h1>Celeste-like JS Platformer</h1>
    <div>
      <button id="startProcon" class="btn">プロコンで操作</button>
      <button id="startKeyboard" class="btn">キーボードで操作</button>
    </div>
    <p>操作方法を選んでください</p>
  </div>
</div>
<div id="wrap">
  <canvas id="game"></canvas>
  <div class="ui">
    <h2>操作</h2>
    <ul>
      <li><span class="kbd">←/→</span> or 左スティック/D-Pad … 移動</li>
      <li><span class="kbd">Z</span> or <span class="pill">A (Pro)</span> … ジャンプ（長押しで高く）</li>
      <li><span class="kbd">X</span> or <span class="pill">B (Pro)</span> … ダッシュ（8方向 / 空中1回）</li>
      <li><span class="kbd">C / Shift</span> or <span class="pill">R (Pro)</span> … 壁掴まり</li>
      <li>スーパーダッシュ … <span class="kbd">↓</span> + ダッシュ → すぐジャンプ</li>
      <li><span class="kbd">Enter</span> … リスタート</li>
    </ul>
    <p><button id="enableGamepad" class="btn">コントローラーを有効化</button></p>
    <p style="opacity:.8;font-size:14px">
      ProコンはBluetooth接続推奨。初回はボタンを一度押して認識させてください。<br>
      簡易バイブは対応環境のみ作動します。
    </p>
    <p id="hud"></p>
  </div>
</div>

<script>
// ===== ゲーム本体を関数化 =====
function startGame(gamepadMode) {
  // ====== 基本設定 ======
  const canvas = document.getElementById('game');
  // Make canvas fill the window and update on resize
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;
  const SCALE = 1; // そのままピクセル単位
  const FIXED_DT = 1/60; // 60FPS
  let accumulator = 0, last = performance.now();

  // ====== 入力（Keyboard + Gamepad）=====
  const keys = new Set();
  const justPressed = new Set();
  const btn = (code) => keys.has(code);
  window.addEventListener('keydown', e => { if(!keys.has(e.code)) justPressed.add(e.code); keys.add(e.code); if(e.code==='Enter') reset(); });
  window.addEventListener('keyup', e => { keys.delete(e.code); justPressed.delete(e.code); });

  // Gamepad
  let gamepadEnabled = !!gamepadMode;
  document.getElementById('enableGamepad').addEventListener('click', async () => {
    gamepadEnabled = true;
    navigator.vibrate?.(50);
  });

  // ====== レベル（2Dマップ＆自動生成） ======

  function pollGamepad() {
    const gps = navigator.getGamepads?.() || [];
    for (const gp of gps) {
      if (!gp) continue;
      // 標準マッピング前提（Switch Pro も多くの環境で "standard"）
      const axLX = gp.axes[0] || 0;
      const axLY = gp.axes[1] || 0;
      // 十字
      const dpadL = gp.buttons[14]?.pressed;
      const dpadR = gp.buttons[15]?.pressed;
      const dpadU = gp.buttons[12]?.pressed;
      const dpadD = gp.buttons[13]?.pressed;

      // 左右入力
      gamepad.left  = (axLX < -0.25) || dpadL;
      gamepad.right = (axLX >  0.25) || dpadR;
      gamepad.up    = (axLY < -0.35) || dpadU;
      gamepad.down  = (axLY >  0.35) || dpadD;

      // ボタン（A=0, B=1, X=2, Y=3, LB=4, RB=5, LT=6, RT=7, back=8, start=9, LS=10, RS=11）
      setButtonEdge('gp_jump', gp.buttons[0]?.pressed);  // A
      setButtonEdge('gp_dash', gp.buttons[1]?.pressed);  // B
      gamepad.grab = gp.buttons[5]?.pressed || gp.buttons[4]?.pressed; // RB/LB
    }
  }
  const gamepad = { left:false, right:false, up:false, down:false, grab:false };
  const buttonLatch = { gp_jump:false, gp_dash:false };
  function setButtonEdge(name, pressed){
    if (pressed && !buttonLatch[name]) { justPressed.add(name); }
    buttonLatch[name] = !!pressed;
  }
  function pressedOnce(code){
    const hit = justPressed.has(code);
    if (hit) justPressed.delete(code);
    return hit;
  }

  function inputLeft () { return btn('ArrowLeft') || btn('KeyA') || (gamepadEnabled && gamepad.left); }
  function inputRight() { return btn('ArrowRight')|| btn('KeyD') || (gamepadEnabled && gamepad.right); }
  function inputUp   () { return btn('ArrowUp')   || btn('KeyW') || (gamepadEnabled && gamepad.up); }
  function inputDown () { return btn('ArrowDown') || btn('KeyS') || (gamepadEnabled && gamepad.down); }
  function inputJump () { return btn('KeyZ') || btn('Space') || btn('KeyJ') || (gamepadEnabled && buttonLatch.gp_jump); }
  function inputDash () { return btn('KeyX') || btn('KeyK') || (gamepadEnabled && buttonLatch.gp_dash); }
  function inputGrab () { return btn('KeyC') || btn('ShiftLeft') || btn('ShiftRight') || (gamepadEnabled && gamepad.grab); }
  function pressedJump () { return pressedOnce('KeyZ') || pressedOnce('Space') || pressedOnce('KeyJ') || pressedOnce('gp_jump'); }
  function pressedDash () { return pressedOnce('KeyX') || pressedOnce('KeyK') || pressedOnce('gp_dash'); }

  // ====== レベル（2Dマップ＆自動生成） ======
  // タイルサイズ
  const TILE = 36.5;

  // ステージマップ: "."=空, "#"=>solid, "^"=>spike, "G"=>goal
  // 40x24 (640x384)
  const LEVEL_MAP = [
    "........................................",
    "........................................",
    "........................................",
    "........................................",
    "........................................",
    "........................................",
    "........................................",
    "..................................##....",
    ".......................................#",
    "......................................#.",
    ".....................................#..",
    "...#................................##..",
    "########################################",
  ];

  // 配列LEVEL: [x, y, TILE, TILE, type] (type: 'solid'|'spike'|'goal')
  const LEVEL = [];
  for (let row = 0; row < LEVEL_MAP.length; row++) {
    const line = LEVEL_MAP[row];
    for (let col = 0; col < line.length; col++) {
      const ch = line[col];
      if (ch === "#") {
        LEVEL.push([col*TILE, row*TILE, TILE, TILE, 'solid']);
      } else if (ch === "^") {
        LEVEL.push([col*TILE, row*TILE, TILE, TILE, 'spike']);
      } else if (ch === "G") {
        LEVEL.push([col*TILE, row*TILE, TILE, TILE, 'goal']);
      }
      // "."は空白
    }
  }

  // ====== プレイヤー ======
  const P = {
    x: 30, y: 300,
    w: 36.5, h: 45.5,       // 物理ヒットボックス（見た目より小さめ）
    vx: 0, vy: 0,
    facing: 1,

    // 速度上限と加速度（加速6f, 減速3f）
    maxSpeed: 120,            // px/s
    accel: 1200,              // px/s^2
    decel: 2400,              // px/s^2

    // ジャンプ（36f: 18f上昇 + 18f下降, 最大高=身長×3=48px）
    gravity: 1066.6667,       // 導出値 g = 2h / tup^2, h=48, tup=0.3
    jumpVel: 320,             // v0 = g * tup = 1066.6 * 0.3
    jumpHeld: false,
    jumpMaxHold: 0.18,        // 押し続け猶予（高いジャンプ）
    jumpHoldTimer: 0,

    // コヨーテ / バッファ
    coyoteTime: 0.10,
    coyoteTimer: 0,
    jumpBufferTime: 0.10,
    jumpBufferTimer: 0,

    // ダッシュ
    canDash: true,
    dashing: false,
    dashTime: 0,
    dashLock: 0.15,           // 操作不能期間
    dashSpeed: 400,           // 幅12 → 5倍=60px を0.15sで移動 ≒ 400px/s
    dashDir: {x:0,y:0},
    dashCooldown: 0,          // 終了後のクールダウン短時間
    postDashFriction: 1400,   // 減速

    // 壁掴まり
    grabbing: false,
    onWallLeft: false,
    onWallRight: false,
    wallSlideSpeed: 55,
    stamina: 110,
    staminaDrain: 40,         // /s
    staminaRecover: 55,       // /s (地上)
    wallJumpVelX: 160,
    wallJumpVelY: 280,

    // 壁ホップ（ダッシュ衝突時のふわっと）
    wallHopBoost: 120,

    // スーパーダッシュ（↓+ダッシュ → 直後ジャンプ）
    superDashWindow: 0.12,
    superDashTimer: 0,
    superDashBoost: 140,      // 追加水平ブースト

    // 状態
    onGround: false,
    dead: false,
    goal: false,

    // 演出
    shake: 0,
    trail: [],
    stretch: 0,               // スカッシュ＆ストレッチ: 正で縦伸び/負で横つぶれ
  };

  function reset() {
    Object.assign(P, {
      x: 30, y: 300, vx:0, vy:0, facing:1,
      canDash: true, dashing:false, dashTime:0, dashCooldown:0, dashDir:{x:0,y:0},
      grabbing:false, onWallLeft:false, onWallRight:false, stamina:110,
      onGround:false, dead:false, goal:false,
      coyoteTimer:0, jumpBufferTimer:0, jumpHeld:false, jumpHoldTimer:0,
      superDashTimer:0, trail:[], shake:0, stretch:0
    });
  }

  // ====== 当たり判定 ======
  function rectsAt(x,y,w,h) {
    const hits=[];
    for (const r of LEVEL) {
      const [rx,ry,rw,rh,type]=r;
      if (x < rx+rw && x+w > rx && y < ry+rh && y+h > ry) hits.push(r);
    }
    return hits;
  }
  function collideAndSlide(px,py,pw,ph,vx,vy) {
    let x=px, y=py;
    let onGround=false, hitLeft=false, hitRight=false, hitSpike=false, hitGoal=false;

    // X軸移動
    x += vx * FIXED_DT;
    let hits = rectsAt(x,y,pw,ph);
    for (const r of hits) {
      const [rx,ry,rw,rh,type]=r;
      if (type==='solid') {
        if (vx>0) x = rx - pw; else if (vx<0) x = rx+rw;
        vx = 0;
      } else if (type==='spike') {
        hitSpike = true;
      } else if (type==='goal') {
        hitGoal = true;
      }
    }

    // Y軸移動
    y += vy * FIXED_DT;
    hits = rectsAt(x,y,pw,ph);
    for (const r of hits) {
      const [rx,ry,rw,rh,type]=r;
      if (type==='solid') {
        if (vy>0) { y = ry - ph; vy=0; onGround=true; }
        else if (vy<0) { y = ry+rh; vy=0; }
      } else if (type==='spike') {
        hitSpike = true;
      } else if (type==='goal') {
        hitGoal = true;
      }
    }

    // 壁接地情報
    const leftHits = rectsAt(x-0.5,y,0.5,ph).filter(r=>r[4]==='solid');
    const rightHits= rectsAt(x+pw,y,0.5,ph).filter(r=>r[4]==='solid');
    hitLeft  = leftHits.length>0;
    hitRight = rightHits.length>0;
    // Only allow wall hit when not on ground (for wall grabbing in air)
    return {
      x,
      y,
      vx,
      vy,
      onGround,
      hitLeft: hitLeft && !onGround,
      hitRight: hitRight && !onGround,
      hitSpike,
      hitGoal
    };
  }

  // ====== 効果音（簡易） ======
  const SFX = {
    tick: () => navigator.vibrate?.(20),
    land: () => navigator.vibrate?.([10,0,30]),
    dash: async () => {
      navigator.vibrate?.([30,20,30]);
      // Gamepad haptics (可能なら)
      const gp = (navigator.getGamepads?.()[0]) || null;
      try {
        await gp?.vibrationActuator?.playEffect("dual-rumble", { duration: 80, strongMagnitude: 0.8, weakMagnitude: 0.6 });
      } catch(e){}
    },
    death: () => navigator.vibrate?.([60,60,60]),
    goal: ()  => navigator.vibrate?.([20,20,80])
  };

  // ====== 更新 ======
  function step() {
    // Update canvas size vars if resized
    W = canvas.width;
    H = canvas.height;
    // ===== 入力処理 =====
    if (gamepadEnabled) pollGamepad();

    const left  = inputLeft();
    const right = inputRight();
    const up    = inputUp();
    const down  = inputDown();
    const wantGrab = inputGrab();

    // 水平入力
    let move = 0;
    if (left) move -= 1;
    if (right) move += 1;
    if (move) P.facing = Math.sign(move);

    // ジャンプ/ダッシュ エッジ
    const pressJump = pressedJump();
    const pressDash = pressedDash();

    // デッド・ゴール時は待機
    if (P.dead || P.goal) return;

    // ===== コヨーテ / バッファ 更新 =====
    if (P.onGround) P.coyoteTimer = P.coyoteTime;
    else P.coyoteTimer = Math.max(0, P.coyoteTimer - FIXED_DT);

    if (pressJump) P.jumpBufferTimer = P.jumpBufferTime;
    else P.jumpBufferTimer = Math.max(0, P.jumpBufferTimer - FIXED_DT);

    // ===== ダッシュ処理 =====
    if (!P.dashing && P.canDash && pressDash) {
      // 方向決定：入力なければ向きへ
      let dx = (right?1:0) - (left?1:0);
      let dy = (down?1:0) - (up?1:0);
      if (dx===0 && dy===0) dx = P.facing;
      const len = Math.hypot(dx,dy)||1;
      P.dashing = true;
      P.dashTime = P.dashLock;
      P.canDash = false;
      P.dashDir = { x: dx/len, y: dy/len };
      P.vx = P.dashDir.x * P.dashSpeed;
      P.vy = P.dashDir.y * P.dashSpeed;
      P.superDashTimer = down ? P.superDashWindow : 0; // 下ダッシュ受付
      P.trail.length = 0; // 残像初期化
      P.shake = 6;
      P.stretch = -0.35;
      SFX.dash();
      spawnDust(P.x+P.w/2, P.y+P.h/2, 6);
    } else if (P.dashing) {
      P.dashTime -= FIXED_DT;
      P.trail.push({x:P.x, y:P.y, t:0.2});
      if (P.trail.length > 12) P.trail.shift();
      if (P.dashTime <= 0) {
        // ロック解除・減速開始
        P.dashing = false;
        P.dashCooldown = 0.08;
      }
    } else {
      P.dashCooldown = Math.max(0, P.dashCooldown - FIXED_DT);
    }

    // ===== 水平速度制御（ダッシュ中以外） =====
    if (!P.dashing) {
      if (move !== 0) {
        // 加速
        P.vx = approach(P.vx, move * P.maxSpeed, P.accel * FIXED_DT);
      } else {
        // 減速
        P.vx = approach(P.vx, 0, P.decel * FIXED_DT);
      }
    } else {
      // ダッシュ後の惰性摩擦
      if (P.dashTime <= 0) {
        P.vx = approach(P.vx, 0, P.postDashFriction * FIXED_DT);
        P.vy = approach(P.vy, 0, P.postDashFriction * FIXED_DT);
      }
    }

    // ===== 位置更新 & 衝突 =====
    const before = { x:P.x, y:P.y };
    const res = collideAndSlide(P.x,P.y,P.w,P.h,P.vx,P.vy);
    P.x = res.x; P.y = res.y; P.vx = res.vx; P.vy = res.vy;
    P.onGround = res.onGround;
    P.onWallLeft = res.hitLeft;
    P.onWallRight = res.hitRight;

    // ===== 重力・ジャンプ =====
    if (!P.dashing) {
      // 壁掴まり
      if (wantGrab && (P.onWallLeft || P.onWallRight) && !P.onGround && P.stamina > 0) {
        P.grabbing = true;
        P.vx = 0;
        P.vy = 0;
        P.stamina = Math.max(0, P.stamina - P.staminaDrain * FIXED_DT);
      } else {
        P.grabbing = false;
        // 落下重力
        if (P.vy < 0 && !P.jumpHeld) {
          // 早め離しで強め重力
          P.vy += P.gravity * 1.25 * FIXED_DT;
        } else {
          P.vy += P.gravity * FIXED_DT;
        }
      }

      // 壁スライド時の僅かな制御
      if (P.grabbing) {
        if (up)    P.vy = -60;
        if (down)  P.vy =  60;
      }

      // ジャンプ成立（地面 or コヨーテ or 壁）
      let didJump = false;
      if (P.jumpBufferTimer > 0) {
        if (P.coyoteTimer > 0) {
          // 地上/コヨーテジャンプ
          P.vy = -P.jumpVel;
          P.onGround = false;
          P.jumpBufferTimer = 0;
          P.jumpHeld = true; P.jumpHoldTimer = P.jumpMaxHold;
          P.stretch = 0.35;
          spawnDust(P.x+P.w/2, P.y+P.h, 8);
          SFX.tick();
          didJump = true;
        } else if (P.grabbing) {
          // 壁ジャンプ
          const dir = P.onWallLeft ? 1 : -1;
          P.vx = dir * P.wallJumpVelX;
          P.vy = -P.wallJumpVelY;
          P.grabbing = false;
          P.jumpBufferTimer = 0;
          P.jumpHeld = true; P.jumpHoldTimer = P.jumpMaxHold * 0.8;
          P.stretch = 0.35;
          SFX.tick();
          didJump = true;
        }
      }

      // 可変ジャンプ（長押し）
      if (didJump) {
        // スーパーダッシュ成立（下ダッシュ→ジャンプ短時間）
        if (P.superDashTimer > 0) {
          P.vx += P.facing * P.superDashBoost;
          P.superDashTimer = 0;
          spawnDust(P.x+P.w/2, P.y+P.h/2, 10);
          P.shake = 4;
        }
      }
      if (P.jumpHeld) {
        P.jumpHoldTimer -= FIXED_DT;
        if (!inputJump() || P.jumpHoldTimer <= 0) P.jumpHeld = false;
      }
    } else {
      // ダッシュ中は入力無効（ロック）
    }

    // 壁ホップ（ダッシュで壁に当たった瞬間にふわっと）
    if (P.dashing && P.dashTime>0 && (res.hitLeft || res.hitRight)) {
      P.vy = Math.min(P.vy, -P.wallHopBoost);
    }

    // 地上で回復
    if (P.onGround) {
      P.stamina = Math.min(110, P.stamina + P.staminaRecover * FIXED_DT);
      if (before.y < P.y - 0.1) { // 着地検知（上から落ちた）
        P.stretch = -0.25;
        spawnDust(P.x+P.w/2, P.y+P.h, 8);
        SFX.land();
      }
      // 地上に着いたらダッシュ回復
      P.canDash = true;
    }

    // 画面外落下
    if (P.y > H + 40 || res.hitSpike) {
      P.dead = true; SFX.death(); P.shake = 10;
      setTimeout(reset, 280);
    }
    if (res.hitGoal) {
      P.goal = true; SFX.goal(); P.shake = 6;
      setTimeout(reset, 1200);
    }

    // 演出タイマー
    if (P.shake > 0) P.shake -= 1;
    P.stretch = approach(P.stretch, 0, 0.08);

    // 残像寿命
    for (const t of P.trail) t.t -= FIXED_DT;
    while (P.trail.length && P.trail[0].t<=0) P.trail.shift();

    // デバッグHUD
    const hud = document.getElementById('hud');
    hud.innerHTML = `Dash:${P.canDash?'OK':'NG'} / Grab:${P.grabbing?'YES':'NO'} / Stamina:${P.stamina.toFixed(0)} / Coyote:${P.coyoteTimer.toFixed(2)} / Buffer:${P.jumpBufferTimer.toFixed(2)}`;
  }

  // ====== 描画 ======
  function draw() {
    // スクリーンシェイク
    const sx = P.shake>0 ? (Math.random()*P.shake - P.shake/2) : 0;
    const sy = P.shake>0 ? (Math.random()*P.shake - P.shake/2) : 0;

    ctx.save();
    ctx.translate(sx, sy);

    // 背景
    ctx.fillStyle = '#0f1430';
    ctx.fillRect(0,0,W,H);
    // パララックス風
    for (let i=0;i<6;i++){
      ctx.fillStyle = `rgba(100,140,255,${0.06*(i+1)})`;
      const y = 40 + i*18;
      ctx.fillRect(-((P.x*0.2)%W), y, W*2, 2);
    }

    // タイル
    for (const [x,y,w,h,type] of LEVEL) {
      if (type==='solid'){
        ctx.fillStyle = '#2b3366';
      } else if (type==='spike') {
        ctx.fillStyle = '#9d304d';
      } else {
        ctx.fillStyle = '#2a9d8f';
      }
      ctx.fillRect(Math.round(x), Math.round(y), w, h);
      if (type==='spike') {
        // トゲ模様
        for (let i=0;i<w;i+=8){
          ctx.beginPath();
          ctx.moveTo(x+i, y);
          ctx.lineTo(x+i+4, y-6);
          ctx.lineTo(x+i+8, y);
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // ダッシュ残像
    for (const t of P.trail) {
      const alpha = Math.max(0, Math.min(1, t.t/0.2));
      drawPlayer(t.x, t.y, alpha*0.4, true);
    }

    // プレイヤー
    drawPlayer(P.x, P.y, 1, false);

    ctx.restore();
  }

  function drawPlayer(x,y,alpha=1,ghost=false) {
    ctx.save();
    ctx.globalAlpha = alpha;

    // スカッシュ＆ストレッチ
    const cx = x + P.w/2;
    const cy = y + P.h/2;
    const k = P.stretch; // -0.3 .. +0.3
    const sx = 1 - Math.max(0, -k)*0.5;
    const sy = 1 + Math.max(0,  k)*0.6;
    ctx.translate(cx, cy);
    ctx.scale(sx, sy);
    ctx.translate(-cx, -cy);

    // 体
    ctx.fillStyle = ghost ? 'rgba(200,220,255,0.25)' : '#cbd8ff';
    ctx.fillRect(Math.round(x), Math.round(y), P.w, P.h);
    // 顔/髪（向き）
    ctx.fillStyle = ghost ? 'rgba(255,255,255,0.15)' : '#ffffff';
    const eyeX = P.facing>0 ? x+P.w-5 : x+3;
    ctx.fillRect(Math.round(eyeX), Math.round(y+5), 2,2);
    // 白い光（ダッシュ演出）
    if (P.dashing) {
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(Math.round(x-2), Math.round(y+3), P.w+4, 2);
      ctx.fillRect(Math.round(x-1), Math.round(y+P.h-5), P.w+2, 2);
    }
    ctx.restore();

    // 影
    ctx.globalAlpha = 0.20 * alpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(Math.round(x), Math.round(y+P.h), P.w, 3);
    ctx.globalAlpha = 1;
  }

  // ====== 砂埃パーティクル ======
  const dust = [];
  function spawnDust(x,y,n=6){
    for (let i=0;i<n;i++){
      dust.push({x:x+(Math.random()*6-3), y:y+(Math.random()*4-2), vx:(Math.random()*80-40), vy:(-60 - Math.random()*60), t:0.25});
    }
  }
  function updateDust(){
    for (const p of dust){
      p.t -= FIXED_DT;
      p.vy += 900 * FIXED_DT;
      p.x += p.vx * FIXED_DT;
      p.y += p.vy * FIXED_DT;
    }
    while (dust.length && dust[0].t<=0) dust.shift();
  }
  function drawDust(){
    for (const p of dust){
      const a = Math.max(0, p.t/0.25);
      ctx.globalAlpha = a*0.5;
      ctx.fillStyle = '#cbd8ff';
      ctx.fillRect(Math.round(p.x), Math.round(p.y), 2,2);
    }
    ctx.globalAlpha = 1;
  }

  // ====== 補助 ======
  function approach(v, target, delta){
    if (v < target) return Math.min(target, v + delta);
    if (v > target) return Math.max(target, v - delta);
    return target;
  }

  // ====== ループ ======
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    accumulator += dt;
    while (accumulator >= FIXED_DT) {
      step();
      updateDust();
      accumulator -= FIXED_DT;
    }
    draw();
    drawDust();
    requestAnimationFrame(loop);
  }
  reset();
  requestAnimationFrame(loop);
}
</script>
<script>
// ===== スタート画面ロジック =====
window.addEventListener('DOMContentLoaded', function() {
  const startScreen = document.getElementById('startScreen');
  const wrap = document.getElementById('wrap');
  const uiDiv = document.querySelector('.ui');
  const canvas = document.getElementById('game');
  function hideStartScreen() {
    startScreen.style.display = 'none';
    // Hide UI and remove margins for full screen
    if (uiDiv) {
      uiDiv.style.display = 'none';
      uiDiv.style.margin = '0';
      uiDiv.style.padding = '0';
    }
    if (wrap) {
      wrap.style.gap = '0';
      wrap.style.padding = '0';
      wrap.style.margin = '0';
      wrap.style.alignItems = 'stretch';
    }
    if (canvas) {
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      canvas.style.margin = '0';
      canvas.style.padding = '0';
      canvas.style.display = 'block';
      canvas.style.border = 'none';
      canvas.style.boxShadow = 'none';
      canvas.style.borderRadius = '0';
    }
    document.body.style.margin = '0';
    document.body.style.padding = '0';
  }
  document.getElementById('startProcon').addEventListener('click', function() {
    // Request fullscreen before starting game
    if (document.body.requestFullscreen) {
      document.body.requestFullscreen();
    } else if (document.body.webkitRequestFullscreen) {
      document.body.webkitRequestFullscreen();
    } else if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen();
    }
    hideStartScreen();
    startGame(true);
  });
  document.getElementById('startKeyboard').addEventListener('click', function() {
    // Request fullscreen before starting game
    if (document.body.requestFullscreen) {
      document.body.requestFullscreen();
    } else if (document.body.webkitRequestFullscreen) {
      document.body.webkitRequestFullscreen();
    } else if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen();
    }
    hideStartScreen();
    startGame(false);
  });
});
</script>
</body>
</html>
